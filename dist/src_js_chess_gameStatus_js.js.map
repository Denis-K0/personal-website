{"version":3,"file":"src_js_chess_gameStatus_js.js","mappings":";;;;;;;;;;;;;;;AAAY;;AAEZ,CAA2F;AACnD;;AAEjC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,IAAI,iDAAQ,eAAe;AACnD,4BAA4B,IAAI,iDAAQ,kBAAkB;AAC1D,oBAAoB,iDAAQ;AAC5B;AACA;AACA,oBAAoB,+DAAa,WAAW,iDAAQ;AACpD,uBAAuB,sEAAoB,qBAAqB,+DAAa;AAC7E,8CAA8C,+DAAa,gCAAgC,+DAAa;AACxG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,2BAA2B,iDAAQ;;AAEnC;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,QAAQ,+DAAa;;AAErB;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,+DAAa;AACzB;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AChKqD;AACP;AACV;;AAEpC;;AAEA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mDAAmD,iDAAQ;AAC3D,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,kBAAkB;AAC1C,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,4CAAK;AACpF;;AAEA;AACA,sFAAsF,4CAAK;;AAE3F;;AAEA;AACA;AACA,KAAK;AACL;AACA,WAAW,iDAAQ;AACnB;AACA;AACA;AACA,WAAW,iDAAQ;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,gBAAgB,EAAE,uDAAkB;AACpD,YAAY,iDAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,mDAAU,wBAAwB,yBAAyB;AAC3E;AACA,cAAc;AACd;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qDAAqD,iDAAQ;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ,iDAAQ;AAChB,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;;;;;;;;;;;;;;;AC7TY;;AAEZ,CAAyC;;;AAGzC;AACO;AACP;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,iDAAQ;AACzE;AACA;;AAEA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC5Ra;;AAEyE;AAC9B;AAC1B;AACK;;AAE5B;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAM;;AAE5C,QAAQ,2DAAS;AACjB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,4CAAK;AACjB,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,0EAA0E;AAC1E,0EAA0E;AAC1E;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,kBAAkB;AAC1C,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0BAA0B,+DAAa;AACvC;AACA,2BAA2B,+DAAa;;AAExC,gBAAgB,gBAAgB,EAAE,iEAAkB;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,2BAA2B;AACnD,4BAA4B,8BAA8B;AAC1D;AACA;AACA,oBAAoB,+DAAa;AACjC,uBAAuB,sEAAoB,qBAAqB,+DAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,QAAQ,4CAAK;;AAEb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;;;;;;;;;;;;;AChKY;;AAEZ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb;AACA;AACA","sources":["webpack://portfolio-page/./src/js/chess/ai.js","webpack://portfolio-page/./src/js/chess/gameLogic/pieceMove.js","webpack://portfolio-page/./src/js/chess/gameLogic/pieces.js","webpack://portfolio-page/./src/js/chess/gameStatus.js","webpack://portfolio-page/./src/js/chess/popUp.js"],"sourcesContent":["'use strict'\n\nimport { selectPieceFunctions, selectingData, turnExecution } from \"./gameLogic/pieceMove\";\nimport { coreData } from \"./gameStatus\";\n\nexport const aiTurn = {\n    playerColor: 'Black',\n    aiAvailableMoves: {\n        pawn01: [['pawn01Black'], []],\n        pawn02: [['pawn02Black'], []],\n        pawn03: [['pawn03Black'], []],\n        pawn04: [['pawn04Black'], []],\n        pawn05: [['pawn05Black'], []],\n        pawn06: [['pawn06Black'], []],\n        pawn07: [['pawn07Black'], []],\n        pawn08: [['pawn08Black'], []],\n        tower01: [['tower01Black'], []],\n        tower02: [['tower02Black'], []],\n        knight01: [['knight01Black'], []],\n        knight02: [['knight02Black'], []],\n        bishop01: [['bishop01Black'], []],\n        bishop02: [['bishop02Black'], []],\n        queen01: [['queen01Black'], []],\n        queen02: [['queen02Black'], []],\n        king01: [['king01Black'], []],\n    },\n    executeAiTurn() {\n\n        this.resetAiAvailableMoves();\n        \n        this.checkValidMoves();\n\n        let [ choosenPiece, choosenMove ] = this.evaluateMoves();\n\n        // console.log(choosenPiece, choosenMove);\n\n        this.placeTurn(choosenPiece, choosenMove);\n    },\n    checkValidMoves() {\n        // Detect all own pieces\n        for (let i = 0; i < coreData.board.length; i++) {\n            for (let j = 0; j < coreData.board[i].length; j++) {\n                if (coreData.board[i][j].includes(this.playerColor)) {\n                    // console.log(coreData.board[i][j])\n                    // Check if they have a available move\n                    selectingData.pieceId = coreData.board[i][j];\n                    if(selectPieceFunctions.calculateValidMoves(selectingData.pieceName)) {\n                        this.aiAvailableMoves[selectingData.pieceId.slice(0, -5)][1] = [...selectingData.availableMoves];\n                    };\n                };\n            };\n        };  \n    },\n    evaluateMoves() {\n        let bestMove = null;\n        let bestScore = 0;\n\n        for (const piece in this.aiAvailableMoves) {\n            const pieceData = this.aiAvailableMoves[piece];\n            const pieceName = pieceData[0][0];\n            const moves = pieceData[1];\n\n            for (const move of moves) {\n                // Evaluate the move\n                if(move.length === 0) continue;\n                const score = this.evaluateMove(move);\n    \n                // Save the best move\n                if (score > bestScore) {\n                    bestScore = score;\n                    // console.log(bestScore, 'Piece:', pieceName);\n                    bestMove = [ pieceName, move ];\n                };\n            };\n        };\n\n        return bestMove;\n    },\n    evaluateMove(move) {\n        const [ row, col ] = move;\n\n        const enemyPiece = coreData.board[row][col];\n\n        if(enemyPiece === '') return this.getFieldValue(row, col);\n\n        let value = this.getPieceValue(enemyPiece) + this.getFieldValue(row, col);\n\n        return value;\n    },\n    getPieceValue(enemyPiece) {\n        if(enemyPiece === 'king01Black') return 20;\n\n        enemyPiece = enemyPiece.slice(0, -7);\n        const value = {\n            pawn: 10,\n            knight: 30,\n            bishop: 30,\n            tower: 50,\n            queen: 100,\n            king: 1000,\n        };\n\n        return value[enemyPiece];\n    },\n    getFieldValue(row, col) {\n        const boardValue = [\n            [1, 2, 2, 2, 2, 2, 2, 1],\n            [2, 3, 4, 4, 4, 3, 3, 2],\n            [2, 4, 6, 7, 7, 6, 4, 2],\n            [2, 4, 7, 8, 8, 7, 4, 2],\n            [2, 4, 7, 8, 8, 7, 4, 2],\n            [2, 4, 6, 7, 7, 6, 4, 2],\n            [2, 3, 4, 4, 4, 4, 3, 2],\n            [1, 2, 2, 2, 2, 2, 2, 1]\n        ];\n\n        return boardValue[row][col];\n    },\n    placeTurn(piece, move) {\n        selectingData.pieceId = piece;\n\n        const fieldId = this.getFieldId(move);\n\n        // Visual sign for the user\n        const field = document.getElementById(fieldId);\n        field.classList.add('highlightedAi');\n\n        setTimeout(function() {\n            turnExecution.executeTurn('ai', fieldId);\n            field.classList.remove('highlightedAi');\n        }, 600);\n        \n    },\n    getFieldId(move) {\n        const [row, col] = move;\n        let fieldNumber = row * 8 + col + 1;\n        if (fieldNumber < 10) fieldNumber = `0` + fieldNumber;\n        return `field${fieldNumber}`;\n    },\n    resetAiAvailableMoves() {\n        this.aiAvailableMoves = {\n            pawn01: [['pawn01Black'], []],\n            pawn02: [['pawn02Black'], []],\n            pawn03: [['pawn03Black'], []],\n            pawn04: [['pawn04Black'], []],\n            pawn05: [['pawn05Black'], []],\n            pawn06: [['pawn06Black'], []],\n            pawn07: [['pawn07Black'], []],\n            pawn08: [['pawn08Black'], []],\n            tower01: [['tower01Black'], []],\n            tower02: [['tower02Black'], []],\n            knight01: [['knight01Black'], []],\n            knight02: [['knight02Black'], []],\n            bishop01: [['bishop01Black'], []],\n            bishop02: [['bishop02Black'], []],\n            queen01: [['queen01Black'], []],\n            queen02: [['queen02Black'], []],\n            king01: [['king01Black'], []],\n        };\n    },\n};","import { coreData, gameStatus } from \"../gameStatus\";\nimport { showPieceMovements } from \"./pieces\";\nimport { PopUp } from \"../popUp.js\";\n\n\"use strict\";\n\n// Handle the Events\nexport const selectors = {\n    get htmlBoard() {\n        return document.querySelectorAll('.fieldCluster');\n    },\n    addEventsToBoard() {\n        selectors.htmlBoard.forEach((cluster) => {\n            cluster.addEventListener('click', selectPieceFunctions.selectPiece);\n            cluster.addEventListener('keydown', KeyDown.handleKeyDownSelectPiece);\n        })\n    },\n    removeEventsFromBoard() {\n        selectors.htmlBoard.forEach((cluster) => {\n            cluster.removeEventListener('click', selectPieceFunctions.selectPiece);\n            cluster.removeEventListener('click', turnExecution.executeTurn);\n            cluster.removeEventListener('click', selectors.deselect);\n\n            cluster.removeEventListener('keydown', KeyDown.handleKeyDownSelectPiece);\n            cluster.removeEventListener('keydown', KeyDown.handleKeyDownExecuteTurn);\n            cluster.removeEventListener('keydown', KeyDown.handleKeyDownDeselect);\n\n            cluster.classList.remove('highlighted');\n        })\n    },\n    addExecuteEventsToBoard() {\n        selectors.htmlBoard.forEach((cluster) => {\n            // Control first, if the Cluster match the possible Moves\n            const clusterNumber = +cluster.id.slice(-2);\n            if(selectors.checkCluster(clusterNumber)) {\n                cluster.addEventListener('click', turnExecution.executeTurn);\n                cluster.addEventListener('keydown', KeyDown.handleKeyDownExecuteTurn);\n                // Add a visual Mark to the Cluster\n                cluster.classList.add('highlighted');\n            } else {\n                cluster.addEventListener('click', selectors.deselect);\n                cluster.addEventListener('keydown', KeyDown.handleKeyDownDeselect);\n            };\n        });\n    },\n    checkCluster(clusterNumber) {\n        for(const move of selectingData.availableMoves) {\n            const [row, col] = move;\n            const field = row * 8 + col + 1;\n            if(field === clusterNumber) {\n                return true;\n            }\n        };\n\n        return false;\n    },\n    displayValidMoves() {\n        selectors.removeEventsFromBoard();\n        selectors.addExecuteEventsToBoard();\n    },\n    deselect() {\n        selectors.removeEventsFromBoard();\n        selectors.addEventsToBoard();\n    },\n};\n\nexport const selectingData = {\n    pieceId: '',\n    availableMoves: [],\n    get pieceName() {\n        return this.getPieceName(this.pieceId);\n    },\n    get piecePosition() {\n        return this.getPiecePosition(this.pieceId, coreData.board);\n    },\n    get pieceColor() {\n        return this.pieceId.includes('White') ? 'White' : 'Black';\n    },\n    get enemyColor() {\n        return this.pieceColor === 'White' ? 'Black' : 'White';\n    },\n    getPieceName(pieceId) {\n        const zeroIndex = pieceId.indexOf('0');\n        return pieceId.slice(0, zeroIndex);\n    },\n    getPiecePosition(pieceId, board) {\n        for (let i = 0; i < board.length; i++) {\n            for (let j = 0; j < board[i].length; j++) {\n                if (board[i][j] === pieceId) {\n                    return [i, j];\n                }\n            }\n        };\n        throw new Error(\"Piece not found on the board! - F:getPiecePosition\");\n    },\n};\n\nexport const selectPieceFunctions = {\n    selectPiece(event) {\n        const cluster = event.currentTarget;\n        selectingData.pieceId = cluster.children[0]?.id ?? 'No Piece in Cluster';\n        // console.log(selectingData.pieceId);\n        \n        // First: Check if the Field is valid to be selected from the Player\n        if(!selectPieceFunctions.checkValidTurn(selectingData.pieceId)) return PopUp.changeMsg('Choose your piece'); \n        // console.log('Valid Turn Success');\n\n        // Second: Calculate the possible moves & store them\n        if(!selectPieceFunctions.calculateValidMoves(selectingData.pieceName)) return PopUp.changeMsg('No available turns');\n\n        // console.log('Avaiable Moves', ...selectingData.availableMoves);\n\n        // Third: Show the User the available Moves\n        selectors.displayValidMoves();\n    },\n    checkValidTurn(pieceId) {\n        if(coreData.round % 2 !== 0) {\n            if(pieceId.includes('White')) return true;\n        };\n    \n        if(coreData.round % 2 === 0) {\n            if(pieceId.includes('Black')) return true;\n        };\n    \n        return false;\n    },\n    calculateValidMoves(pieceName) {\n        const { possibleMoves } = showPieceMovements[pieceName](selectingData.enemyColor, selectingData.piecePosition, \n            coreData.board, selectingData.pieceColor, selectingData.pieceId);\n        \n        // Filter the possibleMoves, if they get in conflict with a danger for the own king\n        selectingData.availableMoves = selectPieceFunctions.filterInvalidMoves(possibleMoves);\n\n        if (selectingData.availableMoves.length === 0) {\n            return false;\n        }\n\n        // console.log('Possible Moves: ', selectingData.availableMoves);\n\n        return true;\n    },\n    filterInvalidMoves(possibleMoves) {\n        const filteredMoves = [];\n\n        // Control by each possible move, if a Check is given \n        for(const move of possibleMoves) {\n            let newBoard = selectPieceFunctions.simulateMove\n            (move, selectingData.pieceId, selectingData.piecePosition, selectingData.pieceColor);\n\n            if(!gameStatus.isKingInCheck(`king01${selectingData.pieceColor}`, newBoard)) {\n                filteredMoves.push(move);\n            } // else console.log('Zug entfernt! ->' + move);\n        };\n\n        return filteredMoves;\n    },\n    // Simulate a board with the to executing Move\n    simulateMove(move, pieceId, piecePosition, pieceColor) {\n        const [targedRow, targedCol] = move;\n        const [currentRow, currentCol] = piecePosition;\n        let createdBoard = JSON.parse(JSON.stringify(coreData.board));\n\n        // If Rochade ist true, then apply it correctly\n        if(createdBoard[targedRow][targedCol].includes('king01' + pieceColor)) {\n           createdBoard = selectPieceFunctions.correctBoardForRochade(createdBoard, pieceId);\n           createdBoard[currentRow][currentCol] = '';\n        //    console.log(\"SimulatedBoard->\", createdBoard)\n           return createdBoard;\n        };\n\n        createdBoard[targedRow][targedCol] = pieceId;\n        createdBoard[currentRow][currentCol] = '';\n\n        // console.log(\"SimulatedBoard->\", createdBoard)\n        return createdBoard;\n    },\n    // Only necessary for the Board-Simulation\n    correctBoardForRochade(createdBoard, towerId) {\n        switch (towerId) {\n            case \"tower01Black\":\n                createdBoard[0][2] = 'king01Black';\n                createdBoard[0][4] = '';\n                createdBoard[0][3] = towerId;\n                return createdBoard;\n            case \"tower02Black\":\n                createdBoard[0][6] = 'king01Black';\n                createdBoard[0][4] = '';\n                createdBoard[0][5] = towerId;\n                return createdBoard;\n            case \"tower01White\":\n                createdBoard[7][2] = 'king01White';\n                createdBoard[7][4] = '';\n                createdBoard[7][3] = towerId;\n                return createdBoard;\n            case \"tower02White\":\n                createdBoard[7][6] = 'king01White';\n                createdBoard[7][4] = '';\n                createdBoard[7][5] = towerId;\n                return createdBoard;\n            default:\n                return console.log(\"Invalid towerId\");\n        };\n    },\n};\n                    \nexport const turnExecution = {\n    queenBlack: document.getElementById('queen01Black').cloneNode(true),\n    queenWhite: document.getElementById('queen01White').cloneNode(true),\n    executeTurn(event, target) {\n        // Get the involved Elements\n        let targetCluster = 0;\n        if(event === 'ai') {\n            targetCluster = document.getElementById(target)\n        } else {\n            targetCluster = event.currentTarget;\n        };\n        const pieceElement = document.getElementById(selectingData.pieceId);\n        const sourceCluster = pieceElement.parentElement;\n\n        // If the Turn contains not a rochade\n        if(!turnExecution.executeRochadeTurn(targetCluster, pieceElement, sourceCluster)) {\n\n            // Set the piece to the target position\n            turnExecution.executeNormalTurn(targetCluster, pieceElement, sourceCluster);\n        };\n\n        // If the Turn contains a promotion\n        turnExecution.executePromotion(targetCluster, pieceElement);\n\n        // Set the board back & update it\n        selectors.removeEventsFromBoard();\n        coreData.updateBoard();\n    },\n\n    executeNormalTurn(targetCluster, pieceElement, sourceCluster) {\n        sourceCluster.removeChild(pieceElement);\n        targetCluster.children[0]?.remove();\n        targetCluster.appendChild(pieceElement);\n    },\n    executeRochadeTurn(targetCluster, pieceElement, sourceCluster) {\n        // console.log(selectingData.pieceColor);\n        // console.log(targetCluster.children[0]?.id);\n        if(!targetCluster.children[0]?.id.includes('king01' + selectingData.pieceColor)) return false;\n\n        switch (pieceElement.id) {\n            case \"tower01Black\":\n                const kingElement01 = document.getElementById('king01Black');\n                kingElement01.remove();\n                document.getElementById('field03').appendChild(kingElement01);\n                sourceCluster.removeChild(pieceElement);\n                document.getElementById('field04').appendChild(pieceElement);\n                return true;\n            case \"tower02Black\":\n                const kingElement02 = document.getElementById('king01Black');\n                kingElement02.remove();\n                document.getElementById('field07').appendChild(kingElement02);\n                sourceCluster.removeChild(pieceElement);\n                document.getElementById('field06').appendChild(pieceElement);\n                return true;\n            case \"tower01White\":\n                const kingElement03 = document.getElementById('king01White');\n                kingElement03.remove();\n                document.getElementById('field59').appendChild(kingElement03);\n                sourceCluster.removeChild(pieceElement);\n                document.getElementById('field60').appendChild(pieceElement);\n                return true;\n            case \"tower02White\":\n                const kingElement04 = document.getElementById('king01White');\n                kingElement04.remove();\n                document.getElementById('field63').appendChild(kingElement04);\n                sourceCluster.removeChild(pieceElement);\n                document.getElementById('field62').appendChild(pieceElement);\n                return true;\n            default:\n                return false;\n        };\n    },\n    executePromotion(targetCluster, pieceElement) {\n        if(!pieceElement.id.includes('pawn')) return;\n\n        if(targetCluster.id.includes('01') || targetCluster.id.includes('02') ||\n        targetCluster.id.includes('03') || targetCluster.id.includes('04') ||\n        targetCluster.id.includes('05') || targetCluster.id.includes('06') ||\n        targetCluster.id.includes('07') || targetCluster.id.includes('08')) {\n            pieceElement.remove();\n            turnExecution.queenWhite.id = 'queen02White';\n            targetCluster.appendChild(turnExecution.queenWhite);\n        };\n\n        if(targetCluster.id.includes('64') || targetCluster.id.includes('63') ||\n        targetCluster.id.includes('62') || targetCluster.id.includes('61') ||\n        targetCluster.id.includes('60') || targetCluster.id.includes('59') ||\n        targetCluster.id.includes('58') || targetCluster.id.includes('57')) {\n            pieceElement.remove();\n            turnExecution.queenBlack.id = 'queen02Black';\n            targetCluster.appendChild(turnExecution.queenBlack);\n        };\n    },\n};\n\nconst KeyDown = {\n    handleKeyDownSelectPiece(event) {\n        if (event.key === 'Enter') {\n            selectPieceFunctions.selectPiece(event);\n        };\n    },\n    handleKeyDownExecuteTurn(event) {\n        if (event.key === 'Enter') {\n            turnExecution.executeTurn(event);\n        };\n    },\n    handleKeyDownDeselect(event) {\n        if (event.key === 'Enter') {\n            selectors.deselect();\n        };\n    },\n\n}","\"use strict\"\n\nimport { coreData } from \"../gameStatus\";\n\n\n// Obj. that serve as a Output for each Piece\nexport const showPieceMovements =  {\n    pawn(enemyColor, piecePosition, board, pieceColor) {\n        let possibleMoves = [];\n        possibleMoves.push(...moves.getPawnMoves(enemyColor, piecePosition, board, pieceColor));\n        return { possibleMoves };\n    },\n    tower(enemyColor, piecePosition, board, pieceColor, pieceId, check) {\n        let possibleMoves = [];\n        possibleMoves.push(...moves.getTowerMoves(enemyColor, piecePosition, board, pieceColor));\n        possibleMoves.push(...moves.getRochadMoves(enemyColor, piecePosition, board, pieceColor, pieceId));\n        return { possibleMoves };\n    },\n    knight(enemyColor, piecePosition, board, pieceColor) {\n        let possibleMoves = [];\n        possibleMoves.push(...moves.getKnightMoves(enemyColor, piecePosition, board, pieceColor));\n        return { possibleMoves };\n    },\n    bishop(enemyColor, piecePosition, board, pieceColor) {\n        let possibleMoves = [];\n        possibleMoves.push(...moves.getBishopMoves(enemyColor, piecePosition, board, pieceColor));\n        return { possibleMoves };\n    },\n    queen(enemyColor, piecePosition, board, pieceColor) {\n        let possibleMoves = [];\n        possibleMoves.push(...moves.getTowerMoves(enemyColor, piecePosition, board, pieceColor));\n        possibleMoves.push(...moves.getBishopMoves(enemyColor, piecePosition, board, pieceColor));\n        return { possibleMoves };\n    },\n    king(enemyColor, piecePosition, board, pieceColor) {\n        let possibleMoves = [];\n        possibleMoves.push(...moves.getKingMoves(enemyColor, piecePosition, board, pieceColor));\n        return { possibleMoves };\n    },\n};\n\nconst moves = {\n    getPawnMoves(enemyColor, piecePosition, board, pieceColor) {\n        const direction = (pieceColor === 'White') ? -1 : 1;\n        const [row, col] = piecePosition;\n        let movePoints = [];\n    \n        function getMoves() {\n            // Single-Step\n            if (row + direction < 0 || row + direction > 7 || col < 0 || col > 7) return; // Control first the board border\n            if(board[row + direction][col] === '') {\n                movePoints.push([row + direction, col]);\n            } else return;\n    \n            // Double-Step\n            if (row + (direction * 2) < 0 || row + (direction * 2) > 7 || col < 0 || col > 7) return;\n            if(board[row + (direction * 2)][ col] !== '') return;\n            if ((pieceColor === 'White' && row === 6) || (pieceColor === 'Black' && row === 1)) {\n                    movePoints.push([row + (direction * 2), col]);\n                };\n        };\n    \n        function getAttacks() {\n            // Left-Attack\n            if (row + direction >= 0 && row + direction <= 7 && col - 1 >= 0 && (col - 1) <= 7) {\n                if(board[row + direction][col - 1] !== '') {\n                    if(board[row + direction][col - 1].includes(enemyColor)) {\n                        movePoints.push([row + direction, col - 1]);\n                    };\n                };\n            };\n    \n            // Right-Attack\n            if (row + direction >= 0 && row + direction <= 7 && (col + 1) >= 0 && (col + 1) <= 7){\n                if(board[row + direction][col + 1] !== '') {\n                    if(board[row + direction][col + 1].includes(enemyColor)) {\n                        movePoints.push([row + direction, col + 1]);\n                    };\n                };\n            };\n        };\n    \n        getMoves();\n        getAttacks();\n    \n        return movePoints;\n    },\n\n    getTowerMoves(enemyColor, piecePosition, board) {\n        const [row, col] = piecePosition;\n        let movePoints = [];\n    \n        // Movement-Forward\n        for(let i = row + 1; i < 8; i++) {\n            if(board[i][col] !== '') {\n                if(board[i][col].includes(enemyColor)) {\n                    movePoints.push([i, col]);\n                };\n                break;\n            };\n            movePoints.push([i, col]);\n        };\n    \n        // Movement-Backwards\n        for(let i = row - 1; i >= 0; i--) {\n            if(board[i][col] !== '') {\n                if(board[i][col].includes(enemyColor)) {\n                    movePoints.push([i, col]);\n                };\n                break;\n            };\n            movePoints.push([i, col]);\n        };\n    \n        // Movement-Right\n        for(let i = col + 1; i < 8; i++) {\n            if(board[row][i] !== '') {\n                if(board[row][i].includes(enemyColor)) {\n                    movePoints.push([row, i]);\n                };\n                break;\n            };\n            movePoints.push([row, i]);\n        };\n    \n        // Movement-Left\n        for(let i = col - 1; i >= 0; i--) {\n            if(board[row][i] !== '') {\n                if(board[row][i].includes(enemyColor)) {\n                    movePoints.push([row, i]);\n                };\n                break;\n            };\n            movePoints.push([row, i]);\n        };\n    \n        return movePoints;\n    },\n    \n    getRochadMoves(enemyColor, piecePosition, board, pieceColor, pieceId) {\n        let [row, col] = piecePosition;\n        let movePoints = [];\n    \n        function checkTowerConditions() {\n            if(pieceId === 'tower01Black' && piecePosition.toString() === '0,0') return true;\n            if(pieceId === 'tower02Black' && piecePosition.toString() === '0,7') return true;\n            if(pieceId === 'tower01White' && piecePosition.toString() === '7,0') return true;\n            if(pieceId === 'tower02White' && piecePosition.toString() === '7,7') return true;\n            return false;\n        };\n    \n        function checkKingConditions() {\n            if(pieceColor === 'White' && board[7][4] === 'king01White') return true;\n            if(pieceColor === 'Black' && board[0][4] === 'king01Black') return true;\n            return false;\n        };\n    \n        if (!checkTowerConditions() || !checkKingConditions() || coreData[pieceColor].check) return movePoints;\n    \n        row = (pieceColor === 'White') ? 7 : 0;\n\n        // Rochade to the Right\n        if(pieceId.includes('01')) {\n            for(let i = col + 1; i <= 4; i++) {\n                if(board[row][i] !== '') {\n                    if(board[row][i].includes('king') && board[row][i].includes(pieceColor)) {\n                        // console.log('Rochade accepted');\n                        movePoints.push([row, i]);\n                    } else break;\n                };\n            };\n        };\n\n        // Rochade to the Left\n        if(pieceId.includes('02')) {\n            for(let i = col - 1; i >= 4; i--) {\n                if(board[row][i] !== '') {\n                    if(board[row][i].includes('king') && board[row][i].includes(pieceColor)) {\n                        // console.log('Rochade accepted');\n                        movePoints.push([row, i]);\n                    } else break;\n                };\n            };\n        };\n\n        return movePoints;\n    },\n    \n    getKnightMoves(enemyColor, piecePosition, board) {\n        const [row, col] = piecePosition;\n        let movePoints = [];\n    \n        const directions =  [[2, 1], [2, -1], [1, 2], [-1, 2],\n                            [-2, 1], [-2, -1], [1, -2], [-1, -2],\n        ];\n    \n        directions.forEach(([rowIncrement, colIncrement]) => {\n            const newRow = rowIncrement + row;\n            const newCol = colIncrement + col;\n    \n            if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) return;\n    \n            if(board[newRow][newCol] === '') \n                return movePoints.push([newRow, newCol]);\n            if(board[newRow][newCol].includes(enemyColor)) \n                return movePoints.push([newRow, newCol]);\n        });\n    \n        return movePoints;\n    },\n    \n    getBishopMoves(enemyColor, piecePosition, board) {\n        const [row, col] = piecePosition;\n        let movePoints = [];\n    \n        // Movement-TopRight\n        for(let i = row + 1, j = col + 1; i < 8 && j < 8; i++, j++) {\n            if(board[i][j] !== '') {\n                if(board[i][j].includes(enemyColor)) {\n                    movePoints.push([i, j]);\n                };\n                break;\n            };\n            movePoints.push([i, j]);\n        };\n    \n        // Movement-TopLeft\n        for(let i = row + 1, j = col - 1; i < 8 && j >= 0; i++, j--) {\n            if(board[i][j] !== '') {\n                if(board[i][j].includes(enemyColor)) {\n                    movePoints.push([i, j]);\n                };\n                break;\n            };\n            movePoints.push([i, j]);\n        };\n    \n        // Movement-DownLeft\n        for(let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if(board[i][j] !== '') {\n                if(board[i][j].includes(enemyColor)) {\n                    movePoints.push([i, j]);\n                };\n                break;\n            };\n            movePoints.push([i, j]);\n        };\n    \n        // Movement-DownRight\n        for(let i = row - 1, j = col + 1; i >= 0 && j < 8; i--, j++) {\n            if(board[i][j] !== '') {\n                if(board[i][j].includes(enemyColor)) {\n                    movePoints.push([i, j]);\n                };\n                break;\n            };\n            movePoints.push([i, j]);\n        };\n    \n        return movePoints;\n    },\n    \n    getKingMoves(enemyColor, piecePosition, board,) {\n        const [row, col] = piecePosition;\n        let movePoints = [];\n        const directions = [[1, 0], [1, 1], [0, 1],\n                            [-1, 1], /* King */ [-1, 0], \n                            [-1, -1], [0, -1], [1, -1],\n        ];\n    \n        directions.forEach(([rowIncrement, colIncrement]) => {\n            const newRow = rowIncrement + row;\n            const newCol = colIncrement + col;\n            \n            if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) return;\n    \n            if(board[newRow][newCol] === '') \n                return movePoints.push([newRow, newCol]);\n            if(board[newRow][newCol].includes(enemyColor)) \n                return movePoints.push([newRow, newCol]);\n        });\n    \n        return movePoints;\n    },\n};","\"use strict\";\n\nimport { selectingData, selectPieceFunctions, selectors} from \"./gameLogic/pieceMove\";\nimport { showPieceMovements } from \"./gameLogic/pieces\";\nimport { aiTurn } from \"./ai\";\nimport { PopUp } from \"./popUp.js\";\n\nexport const coreData = {\n    round: 0,\n    White: {\n        check: false,\n        player01: 'Player01',\n    },\n    Black: {\n        check: false,\n        player02: 'AI',\n    },\n    board: [],\n    getPlayerName() {\n        this.White.player01 = document.getElementById('player01').value;\n        this.Black.player02 = document.getElementById('player02').value || 'AI';\n    },\n    // Update the Board Array depending on the board in the DOM\n    updateBoard() {\n        const htmlBoard = document.querySelectorAll('.fieldCluster');\n        this.board = [[], [], [], [], [], [], [], []];\n        let i = 0;\n        \n        // The Board Update\n        htmlBoard.forEach((boardCluster) => {\n    \n            // When a row is full, jump to the next\n            if (this.board[0 + i].length === 8) {\n                i++;\n            };\n    \n            this.board[0 + i].push(boardCluster.children[0]?.id ?? \"\");\n        });\n\n        coreData.countRounds();\n\n        // console.log(coreData);\n\n        if(gameStatus.checkGameStatus()) return gameStatus.runGameOver();\n\n        if(this.checkAiTurn()) return aiTurn.executeAiTurn();\n\n        selectors.addEventsToBoard();\n    },\n    countRounds() {\n        this.round += 1;\n    },\n    checkAiTurn() {\n        if ((this.Black.player02 === 'AI') && (this.round % 2 === 0)) return true;\n        return false;\n    },\n};\n\nexport const gameStatus = {\n    originalHtmlBoard: document.getElementById('board').cloneNode(true),\n    checkGameStatus() {\n        const playerKing = (coreData.round % 2 === 0) ? 'king01Black' : 'king01White';\n        const player = (coreData.round % 2 === 0) ? coreData.Black.player02 : coreData.White.player01;\n        const playerColor = (coreData.round % 2 === 0) ? 'Black' : 'White';\n        const enemyColor = (coreData.round % 2 === 0) ? 'White' : 'Black';\n        \n        if(this.isKingInCheck(playerKing, coreData.board)) {\n            coreData[playerColor].check = true;\n\n            PopUp.changeMsg(player + ' is in Check!')\n        } else {\n            coreData[enemyColor].check = false;\n            coreData[playerColor].check = false;\n        };\n        \n        if(this.checkMate(playerColor)) return true;\n\n        return false;\n    },\n    // Arguments 'king' & 'board' are always necessary\n    isKingInCheck(king, board) {\n        const dangerColor = king.includes('Black') ? 'White' : 'Black';   // Enemy Color\n        const pieceColor = (dangerColor === 'Black') ? 'White' : 'Black'; // Own Color\n        \n        // If one Move of the Enemy get the own King in danger\n        if(this.detectAllEnemies(king, board, dangerColor, pieceColor)) return true;\n\n        return false;\n    },\n    // Detect all Enemies in the Board\n    detectAllEnemies(king, board, dangerColor, pieceColor) {\n        for (let i = 0; i < board.length; i++) {\n            for (let j = 0; j < board[i].length; j++) {\n                if (board[i][j].includes(dangerColor)) {\n                    if(this.collectAllMoves(king, board, dangerColor, pieceColor, i, j)) return true;\n                };\n            };\n        };\n        return false;\n    },\n    // Collect all possible Moves from the Enemy\n    collectAllMoves(king, board, dangerColor, pieceColor, i, j) {\n        let dangerId = board[i][j];\n        let dangerName =  selectingData.getPieceName(dangerId);\n        let dangerPosition = [i, j];\n        let kingPosition = selectingData.getPiecePosition(king, board);\n\n        const { possibleMoves } = showPieceMovements[dangerName]\n        (pieceColor, dangerPosition, board, dangerColor, dangerId);\n        \n        if(this.controlMoveMatch(possibleMoves, kingPosition)) return true;\n        return false;\n    },\n    // Control if one Move match to the Position of the King\n    controlMoveMatch(possibleMoves, kingPosition) {\n        for (const move of possibleMoves) {\n            if (move[0] === kingPosition[0] && move[1] === kingPosition[1]) {\n                // console.log(\"Zug entfernt\");\n                return true;\n            };\n        };\n        return false;\n    },\n    checkMate(playerColor) {\n        // Detect all own pieces\n        for (let i = 0; i < coreData.board.length; i++) {\n            for (let j = 0; j < coreData.board[i].length; j++) {\n                if (coreData.board[i][j].includes(playerColor)) {\n                    // Check if they have a available Move\n                    selectingData.pieceId = coreData.board[i][j];\n                    if(selectPieceFunctions.calculateValidMoves(selectingData.pieceName)) {\n                        return false;\n                    };\n                };\n            };\n        };  \n        return true;\n    },\n    runGameOver() {\n        const winner = (coreData.round % 2 === 0) ? \n        coreData.White.player01 : coreData.Black.player02;\n\n        PopUp.changeMsg(winner + ' won the game! Congratulation!')\n\n        setTimeout(function() {\n            gameStatus.resetGame();\n        }, 5050);\n        \n    },\n    resetGame() {\n        coreData.round = 0;\n        // Reset the Board\n        document.getElementById('board').remove();\n\n        const newBoard = gameStatus.originalHtmlBoard.cloneNode(true); \n        newBoard.id = 'board'; \n        document.getElementById('boardInnerBorder').appendChild(newBoard);\n\n        coreData.updateBoard();\n    },\n};","\"use strict\"\n\nconst PopUp = {\n    get popUp() {\n        return document.getElementById('chessPopUp');\n    },\n    changeMsg(msg) {\n        this.popUp.innerText = msg;\n        this.showAndHide();\n    },\n    showAndHide() {\n        if  (this.popUp.classList.contains('show') &&\n            !this.popUp.innerText.includes('Congratulation')) return;\n\n        if (this.popUp.innerText.includes('Congratulation')) {\n            this.popUp.classList.add('showWin');\n            setTimeout(function() {\n                PopUp.popUp?.classList?.remove('showWin');\n            }, 5050);\n        } else {\n            this.popUp.classList.add('show');\n            setTimeout(function() {\n                PopUp.popUp?.classList?.remove('show');\n            }, 1250);\n        }\n    }\n};\n\nexport { PopUp }"],"names":[],"sourceRoot":""}